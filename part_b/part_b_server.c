// The project aims to execute three programs and communicate between them.
// The server and blackbox programs communicate through pipes while the server 
// and client applications communicate with RPC protocol.
//
// An example server application is generated with rpcgen. 
// The main function of the server application is inside box_call_svc.c file 
// which is generated by rpcgen. In this source code, "call_blackbox_1_svc" function
// which is executed with the RPC call is written. This function takes inputs from the RPC call
// which includes blackbox executable path and two integers, then just like the "part_a" section,
// creates three pipes, forks a child process, loads the blackbox, sends the input integers through
// input pipe and takes back the result string. Instead of writing the result string, 
// this time result string is returned back to client program. The success or fail status is
// appended to result string before sending to client.
//
// @author: Mehmet AkÄ±n Elden

#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
#include "box_call.h"

// In order to avoid mistakes, first define constants for pipe ends
#define READ_END 0
#define WRITE_END 1

// also define the buffer size to be used while reading from pipe
#define BUFFER_SIZE 1024

// actions taken by the child(blackbox) process: pipes are binded to stdin,
// stdout and stderr. Unused ends of the pipes are closed, and the blackbox program
// is loaded.
//  inputPipe: the pipe which will be binded to stdin of the process
//  outputPipe: the pipe which will be binded to stdout of the process
//  errorPipe: the pipe which will be binded to stderr of the process
//  blackbox: the path of the blackbox executable
void child_process(int inputPipe[2], int outputPipe[2], int errorPipe[2], char *blackbox)
{
	// bind read end of the inputPipe to stdin, exit if an error occurs
	if (dup2(inputPipe[READ_END], STDIN_FILENO) < 0)
		exit(-1);

	// bind write end of the outputPipe to stdout, exit if an error occurs
	if (dup2(outputPipe[WRITE_END], STDOUT_FILENO) < 0)
		exit(-1);

	// bind write end of the errorPipe to stderr, exit if an error occurs
	if (dup2(errorPipe[WRITE_END], STDERR_FILENO) < 0)
		exit(-1);

	// close the unused ends of pipes
	close(inputPipe[WRITE_END]);
	close(outputPipe[READ_END]);
	close(errorPipe[READ_END]);

	// binding is completed, load the blackbox and let it do the magic
	if (execl(blackbox, blackbox, NULL) < 0)
	{
		exit(-1);
	}
}

// actions taken by parent process: Unused ends of the pipes are closed,
// two input integers are written to input pipe,
// result is read from stdout if child process exits successfully,
// or result it read from stderr if child exits with error.
// then the result is returned with success or fail status appended to it.
//  inputPipe: the pipe which is binded to stdin of the child process
//  outputPipe: the pipe which is binded to stdout of the child process
//  errorPipe: the pipe which is binded to stderr of the child process
//  inputs: the inputs sent from client program which contains two integers and blackbox path
char** parent_process(int inputPipe[2], int outputPipe[2], int errorPipe[2], inputs *parameters)
{
	// the result string to be returned
	char **result = (char**) malloc(sizeof(char*));
    *result = (char*) malloc(sizeof(char)*BUFFER_SIZE);

    // close the read end of input and write end of output/error pipes
    close(inputPipe[READ_END]);
    close(outputPipe[WRITE_END]);
    close(errorPipe[WRITE_END]);

    // combine two integer parameters in a single string
    char input[BUFFER_SIZE];
	sprintf(input, "%d %d\n", parameters->first, parameters->second);

    // try to write to inputPipe, if cannot write exit with -1
    if (write(inputPipe[WRITE_END], input, BUFFER_SIZE) <= 0)
        exit(-1);

    // wait for child process to finish its job and get the return status
    int status;
    wait(&status);

    // if the exit status of child is not 0, then an error occurred
    int normalExit = 0;
    if (WIFEXITED(status))
    {
        int exitStatus = WEXITSTATUS(status);
        normalExit = exitStatus == 0;
    }

    if (normalExit) // if child terminated normally, read from outputPipe (stdout)
    {
        char buff[BUFFER_SIZE]; // the buffer to read from pipe
        // try to read the result from outputPipe
        if (read(outputPipe[READ_END], buff, sizeof(buff)) > 0)
        {
            // if successfully read, convert response to integer
			int resp = atoi(buff);
			// first add SUCCESS then response to the result string
            sprintf(*result, "SUCCESS:\n%d\n", resp);
        }
        else // if couldn't read, it means something is wrong, return -1
            exit(-1);
    }
    else // if not a normal exit, then read from errorPipe (stderr)
    {
            // initialize a string and try to read from errorPipe
            char msg[BUFFER_SIZE];
            if (read(errorPipe[READ_END], msg, BUFFER_SIZE) > 0) // if some content is read, set result to it
            {
                char* format; // format string to be used for fail message
                if (msg[strlen(msg)-1] == '\n') // if the message ends with newline, don't add newline to format string
                    format = "FAIL:\n%s";
                else
                    format = "FAIL:\n%s\n";
                sprintf(*result, format, msg);
            }
            else // otherwise no data is read, exit with -1
                exit(-1);
    }

    // close pipes and return result
    close(inputPipe[WRITE_END]);
    close(outputPipe[READ_END]);
    close(errorPipe[READ_END]);
    return result;
}

// this function is called by the client request. in this function,
// three pipes are created, a child process is forked and child or parent process
// functions are executed with required parameters.
//  argp: the inputs struct sent from client program
//  rqstp: the service request
//  returns: the result of the blackbox operation if it's parent process
char **call_blackbox_1_svc(inputs *argp, struct svc_req *rqstp)
{
	// Three pipes are required:
    int inputPipe[2];  // For sending the input data to child process. WRITE: parent, READ: child
    int outputPipe[2]; // For receiving the output from child process. WRITE: child, READ: parent
    int errorPipe[2];  // For receiving error message from child process. WRITE: child, READ: parent

    // try to open the pipes, if an error occurs, exit
    if (pipe(inputPipe) < 0 || pipe(outputPipe) < 0 || pipe(errorPipe) < 0)
        exit(-1);

    int pid = fork();
    if (pid == 0) // child process actions
    {
        child_process(inputPipe, outputPipe, errorPipe, argp->blackbox);
    }
    else // parent process actions
    {
		return parent_process(inputPipe, outputPipe, errorPipe, argp);
    }
	return NULL;
}
