// The project aims to execute four programs and communicate between them.
// The server and blackbox programs communicate through pipes, the server 
// and client applications communicate with RPC protocol and the server
// and logger programs communicate through TCP connection.
//
// An example server application is generated with rpcgen. 
// The main function of the server application is inside box_call_svc.c file 
// which is generated by rpcgen. However, in this part, server.h file is included which contains
// global definitions for logger host and port variables. The main function is also adjusted 
// to take the logger host and port arguments from terminal and set the global variable values
// according to parameters. In this source code, "call_blackbox_1_svc" function
// which is executed with the RPC call is written. This function takes inputs from the RPC call
// which includes blackbox executable path and two integers, then just like the "part_b" section,
// creates three pipes, forks a child process, loads the blackbox, sends the input integers through
// input pipe and takes back the result string. Result string is returned back to client program. 
// The success or fail status is appended to result string before sending to client. 
// According to the result a log message is created. Using the global variables 
// logger host and port, log message is sent through TCP connection to the logger program.
//
// @author: Mehmet AkÄ±n Elden

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
#include <arpa/inet.h>
#include "box_call.h"
#include "server.h"

// In order to avoid mistakes, first define constants for pipe ends
#define READ_END 0
#define WRITE_END 1

// also define the buffer size to be used while reading from pipe
#define BUFFER_SIZE 1024

// char logger_host[255] = {};
// int logger_port = 0;

// actions taken by the child(blackbox) process
void child_process(int inputPipe[2], int outputPipe[2], int errorPipe[2], char *blackbox)
{
	// bind read end of the inputPipe to stdin, exit if an error occurs
	if (dup2(inputPipe[READ_END], STDIN_FILENO) < 0)
		exit(-1);

	// bind write end of the outputPipe to stdout, exit if an error occurs
	if (dup2(outputPipe[WRITE_END], STDOUT_FILENO) < 0)
		exit(-1);

	// bind write end of the errorPipe to stderr, exit if an error occurs
	if (dup2(errorPipe[WRITE_END], STDERR_FILENO) < 0)
		exit(-1);

	// close the unused ends of pipes
	close(inputPipe[WRITE_END]);
	close(outputPipe[READ_END]);
	close(errorPipe[READ_END]);

	// binding is completed, load the blackbox and let it do the magic
	if (execl(blackbox, blackbox, NULL) < 0)
	{
		exit(-1);
	}
}

// opening a tcp socket to logger and sending the log
void send_log(char* log)
{
    // create a stream socket with IPv4 domain using default protocol (TCP)
    int sockt = socket(AF_INET, SOCK_STREAM, 0);
    if (sockt < 0)
        return;

    // create logger address
    // host and port are defined in server.h file and assigned in main function of box_call_svc.c file
    struct sockaddr_in logger_addr = {
        .sin_family = AF_INET, // IPv4
        .sin_addr = inet_addr(logger_host),
        .sin_port = logger_port
    };

    // connect socket to logger address, if error occurs, return
    if (connect(sockt, (struct sockaddr*)&logger_addr, sizeof(logger_addr)) < 0)
        return;
    
    // write to the socket
    write(sockt, log, BUFFER_SIZE);

    // wait for response from the logger
    char resp[255] = {};
    read(sockt, resp, sizeof(resp));

    // once the message is read, close the socket and return
    close(sockt);
}

// actions taken by parent process
char** parent_process(int inputPipe[2], int outputPipe[2], int errorPipe[2], inputs *parameters)
{
	// the result string to be returned
	char **result = (char**) malloc(sizeof(char*));
    *result = (char*) malloc(sizeof(char)*BUFFER_SIZE);

    // initialize the log message array
    char log_msg[BUFFER_SIZE] = {};

    // close the read end of input and write end of output/error pipes
    close(inputPipe[READ_END]);
    close(outputPipe[WRITE_END]);
    close(errorPipe[WRITE_END]);

    // combine two integer parameters in a single string
    int first = parameters->first;
    int second = parameters->second;
    char input[BUFFER_SIZE] = {};
	sprintf(input, "%d %d\n", first, second);

    // try to write to inputPipe, if cannot write exit with -1
    if (write(inputPipe[WRITE_END], input, BUFFER_SIZE) <= 0)
        exit(-1);

    // wait for child process to finish its job and get the return status
    int status;
    wait(&status);

    // if the exit status of child is not 0, then an error occurred
    int normalExit = 0;
    if (WIFEXITED(status))
    {
        int exitStatus = WEXITSTATUS(status);
        normalExit = exitStatus == 0;
    }

    if (normalExit) // if child terminated normally, read from outputPipe (stdout)
    {
        char buff[BUFFER_SIZE] = {}; // the buffer to read from pipe
        // try to read the result from outputPipe
        if (read(outputPipe[READ_END], buff, sizeof(buff)) > 0)
        {
            // if successfully read, convert response to integer
			int resp = atoi(buff);
			// first add SUCCESS then response to the result string
            sprintf(*result, "SUCCESS:\n%d\n", resp);
            // also add inputs and response to log message
            sprintf(log_msg, "%d %d %d", first, second, resp);
        }
        else // if couldn't read, it means something is wrong, return -1
            exit(-1);
    }
    else // if not a normal exit, then read from errorPipe (stderr)
    {
        // initialize a string and try to read from errorPipe
        char msg[BUFFER_SIZE] = {};
        if (read(errorPipe[READ_END], msg, BUFFER_SIZE) > 0) // if some content is read, set result to it
        {
            char* format; // format string to be used for fail message
            if (msg[strlen(msg)-1] == '\n') // if the message ends with newline, don't add newline to format string
                format = "FAIL:\n%s";
            else
                format = "FAIL:\n%s\n";
            sprintf(*result, format, msg);
            // also fill log message with empty response
            sprintf(log_msg, "%d %d _", first, second);
        }
        else // otherwise no data is read, exit with -1
            exit(-1);
    }

    // send the log message to logger
    send_log(log_msg);

    // close pipes and return result
    close(inputPipe[WRITE_END]);
    close(outputPipe[READ_END]);
    close(errorPipe[READ_END]);
    return result;
}

// this function is called by the client request, main activity is here
char **call_blackbox_1_svc(inputs *argp, struct svc_req *rqstp)
{
	// Three pipes are required:
    int inputPipe[2];  // For sending the input data to child process. WRITE: parent, READ: child
    int outputPipe[2]; // For receiving the output from child process. WRITE: child, READ: parent
    int errorPipe[2];  // For receiving error message from child process. WRITE: child, READ: parent

    // try to open the pipes, if an error occurs, exit
    if (pipe(inputPipe) < 0 || pipe(outputPipe) < 0 || pipe(errorPipe) < 0)
        exit(-1);

    int pid = fork();
    if (pid == 0) // child process actions
    {
        child_process(inputPipe, outputPipe, errorPipe, argp->blackbox);
    }
    else // parent process actions
    {
		return parent_process(inputPipe, outputPipe, errorPipe, argp);
    }
	return NULL;
}
